load ("lexical_symbols.lisp");

slurp_exprs (f) :=
  block ([s: openr(f), l: [], l1],
         while (l1: ?mread(s)) # false do push(l1, l),
         close (s),
         reverse (l));

declare (explode_mapatoms, global);
explode_mapatoms: false; /* more nearly consistent with built-in listofvars */

setofvars (e) :=
  if mapatom(e)
    then if explode_mapatoms and not atom(e)
           then union (setofvars (op(e)), setofvars (args(e)))
           else (if symbolp(e) or subvarp(e) then (if e # true and e # false and not false_symbol(e) then {e} else {}) else {})
    else block ([op_e: op(e), args_e: args(e), args_vars],
                args_vars: apply (union, map (setofvars, args_e)),
                if member (verbify(op_e), '[sum, lsum, integrate, makelist])
                  then setdifference (args_vars, { second(e) })
                elseif verbify(op_e) = 'at
                  then setdifference (args_vars, if listp (second (e)) then setify (map (first, second (e))) else { second(e) })
                elseif member (verbify(op_e), '[?mdo, ?mdoin]) and first(e) # false
                  then setdifference (args_vars, { first(e) })
                elseif verbify(op_e) = verbify("block")
                  then (if length(e) > 0 and listp (first (e))
                          then block ([local_vars: map (lambda ([e1], if atom(e1) then e1 else lhs(e1)), first(e))],
                                      setdifference (args_vars, setify (local_vars)))
                          else args_vars)
                elseif verbify(op_e) = '?mdefine
                  then setdifference (args_vars, setify (args (first (e))))
                elseif verbify(op_e) = 'lambda
                  then setdifference (args_vars, setify (first (e)))
                  else args_vars); /* IGNORE ANY VARIABLES IN OP, E.G. X in F[X](Y) -- LISTOFVARS DOES TOO */

/* a gyration necessitated by the parser -- $FALSE is tacked onto if-then sans else. Oh well. */
false_symbol (e) := symbolp(e) and ?symbol\-name(e) = "$FALSE";

/* SETOFVARS_GLOBAL AND SETOFVARS_LEXICAL RELY ON LEXICAL SYMBOLS BEING UNINTERNED --
 * THIS IS AN IMPLEMENTATION DETAIL, THEREFORE SUBJECT TO CHANGE
 */
/* MAYBE CALL PARTITION_SET HERE */
setofvars_global ([e]) := subset (block ([explode_mapatoms: true], setofvars (e)), lambda ([x], is (?symbol\-package(x) # false)));
setofvars_lexical ([e]) := subset (block ([explode_mapatoms: true], setofvars (e)), lambda ([x], is (?symbol\-package(x) = false)));
get_global_name (x) := if ?symbol\-package(x) = false then ?get (x, ?reversealias);

defstruct (finfo (op, lexicals, globals));

make_finfo (e) := finfo (op(lhs(e)), map (get_global_name, listify (setofvars_lexical(lhs(e), rhs(e)))), listify (setofvars_global(rhs(e))));

defstruct (callinfo (callee, globalvar, callers));

find_possible_callers (i) :=
  map (lambda ([x], callinfo (i@op, x, map (lambda ([y], y@op), find_possible_callers1 (x)))), i@globals);

find_possible_callers1 (x) := sublist (all_finfo, lambda ([e], member (x, e@lexicals)));

find_possible_dynamic_binding ([filenames]) :=
 (exprs_lists: map (lambda ([f], map (second, slurp_exprs (file_search (f)))), filenames),
  all_exprs: apply (append, exprs_lists),
  all_functions: sublist (all_exprs, lambda ([e], not atom(e) and op(e) = ":=")),
  all_finfo: map (make_finfo, all_functions),
  
  map (find_possible_callers, all_finfo),
  map (lambda ([l], delete (false, l)), %%),
  sublist (%%, lambda ([l], l # [])),
  flatten (%%),
  all_possible_callers: sublist (%%, lambda ([x], x@callers # [])),

  unique (map (lambda ([x], x@globalvar), all_possible_callers)));

/*
linel:200;
for x in all_possible_callers
  do (print (x), print (""));
 */

/*
global_with_no_refs: map (lambda ([x], [x@callee, x@globalvar]), no_callers);
 */

/* a different but related problem -- there exist some constructs like
 * block([foo], foo: foo(x), ...) which makes use of the Lisp-2 concept
 * of function vs value slots on the same symbol, but in a lexical world,
 * foo(x) does not refer to the global function foo.
 */

block
 ([e, b, foolist, barlist, r0, r1],
  matchdeclare (e, lambda ([x], not mapatom(x) and member (op(x), foolist))),
  /* JUST BLOCK BY ITSELF CONFUSES PARSER, ALTHOUGH IT SHOULD BE OK; VERBIFY("BLOCK") IS A WORKAROUND !! */
  /* SEE NOTE ON THIS TOPIC ABOVE DEF-NUD MPROG IN LEXICAL_SYMBOLS.LISP !! */
  matchdeclare (b, lambda ([x], not mapatom(x) and op(x) = verbify("block"))),
  defrule (r0, b, (if listp (first (b))
                     then (foolist: map (lambda ([x], if atom(x) then x else first(x)), first(b)),
                           applyb1 (rest (args (b)), r1)),
                   false)),
  defrule (r1, e, push(e, barlist)),

  find_possible_shadowed_functions ([filenames]) :=
   (exprs_lists: map (lambda ([f], map (second, slurp_exprs (file_search (f)))), filenames),
    all_exprs: apply (append, exprs_lists),
    barlist: [],
    map (lambda ([x], apply1 (x, r0)), all_exprs),
    barlist));
  
