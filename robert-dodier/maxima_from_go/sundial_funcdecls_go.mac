 
General(φ,D,a,z):=block([lines,center,u,ψ],
        returning(block([cφ,sφ,tφ,cD,sD,cz,sz,P,aP],[sφ,cφ]:Sincos[go_type_of(φ)](φ)(),tφ:sφ/cφ,[sD,cD]:Sincos[go_type_of(D)](D)(),
                        [sz,cz]:Sincos[go_type_of(z)](z)(),P:cz*sφ-cD*cφ*sz,
                        for i from 0 unless i >= 24 do
                            continuing(block([l,H,aH,cH,sH],l:block([x:new(Line)],x@Hour:i,x),H:(float64(i-12)*math@Pi)/12,aH:math@Abs(H),
                                             [sH,cH]:math@Sincos(H),
                                             for _ from 0 thru length(m)-1 do
                                                 continuing(block([d:m[_+1]],
                                                                  block([tδ,H0,Q,Nx,Ny],tδ:math@Tan((d*math@Pi)/180),
                                                                        H0:math@Acos(-(tδ*tφ)),if aH > H0 then block([],throw(continue)),
                                                                        Q:P*tδ+cH*(cD*sz*sφ+cz*cφ)+sD*sH*sz,
                                                                        if Q < 0 then block([],throw(continue)),Nx:cD*sH-sD*(cH*sφ-cφ*tδ),
                                                                        Ny:-((sz*sφ+cD*cz*cφ)*tδ)-cH*(cφ*sz-cD*cz*sφ)+cz*sD*sH,
                                                                        l@Points:append(l@Points,Point((Nx*a)/Q,(Ny*a)/Q))))),
                                             if len(l@Points) > 0 then block([],lines:append(lines,l)))),center@X:(a*cφ*sD)/P,
                        center@Y:-((a*(sz*sφ+cD*cz*cφ))/P),aP:math@Abs(P),u:a/aP,ψ:unit@Angle(math@Asin(aP)),throw('return(null)))),
        if %% # null then %% else [lines,center,u,ψ])$
 
 
Equatorial(φ,a):=block([n,s],
           returning(block([tφ],tφ:Tan[go_type_of(φ)](φ)(),
                           for i from 0 unless i >= 24 do
                               continuing(block([nl,sl,H,aH,cH,sH],nl:block([x:new(Line)],x@Hour:i,x),sl:block([x:new(Line)],x@Hour:i,x),
                                                H:(float64(i-12)*math@Pi)/12,aH:math@Abs(H),[sH,cH]:math@Sincos(H),
                                                for _ from 0 thru length(m)-1 do
                                                    continuing(block([d:m[_+1]],
                                                                     block([tδ,H0,x,yy],tδ:math@Tan((d*math@Pi)/180),
                                                                           H0:math@Acos(-(tδ*tφ)),
                                                                           if aH > H0 then block([],throw(continue)),x:-((a*sH)/tδ),
                                                                           yy:(a*cH)/tδ,
                                                                           if tδ < 0 then block([],sl@Points:append(sl@Points,Point(x,yy)))
                                                                               else block([],nl@Points:append(nl@Points,Point(x,-yy)))))),
                                                if len(nl@Points) > 0 then block([],n:append(n,nl)),
                                                if len(sl@Points) > 0 then block([],s:append(s,sl)))),throw('return(null)))),
           if %% # null then %% else [n,s])$
 
 
Horizontal(φ,a):=block([lines,center,u],
           returning(block([cφ,sφ,tφ],[sφ,cφ]:Sincos[go_type_of(φ)](φ)(),tφ:sφ/cφ,
                           for i from 0 unless i >= 24 do
                               continuing(block([l,H,aH,cH,sH],l:block([x:new(Line)],x@Hour:i,x),H:(float64(i-12)*math@Pi)/12,
                                                aH:math@Abs(H),[sH,cH]:math@Sincos(H),
                                                for _ from 0 thru length(m)-1 do
                                                    continuing(block([d:m[_+1]],
                                                                     block([tδ,H0,Q,x,y],tδ:math@Tan((d*math@Pi)/180),
                                                                           H0:math@Acos(-(tδ*tφ)),
                                                                           if aH > H0 then block([],throw(continue)),Q:sφ*tδ+cH*cφ,
                                                                           x:(a*sH)/Q,y:(a*(cH*sφ-cφ*tδ))/Q,
                                                                           l@Points:append(l@Points,Point(x,y))))),
                                                if len(l@Points) > 0 then block([],lines:append(lines,l)))),center@Y:-(a/tφ),
                           u:a/math@Abs(sφ),throw('return(null)))),if %% # null then %% else [lines,center,u])$
 
 
HorizontalByDeclination(φ,a):=block([lines,center,u],
                        returning(block([cφ,sφ,tφ],[sφ,cφ]:Sincos[go_type_of(φ)](φ)(),tφ:sφ/cφ,
                                        for j from 0 thru length(m)-1 do
                                            continuing(block([d:m[j+1]],
                                                             block([l],
                                                                   l:block([x:new(LineWithDeclination)],x@Declination:unit@Angle(d),
                                                                           x@Description:descriptions[j+1],x),
                                                                   for i from 0 unless i >= 24 do
                                                                       continuing(
                                                                       block([H,aH,cH,sH,tδ,H0,Q,x,y],H:(float64(i-12)*math@Pi)/12,
                                                                             aH:math@Abs(H),[sH,cH]:math@Sincos(H),
                                                                             tδ:math@Tan((d*math@Pi)/180),H0:math@Acos(-(tδ*tφ)),
                                                                             if aH > H0 then block([],throw(continue)),Q:sφ*tδ+cH*cφ,
                                                                             x:(a*sH)/Q,y:(a*(cH*sφ-cφ*tδ))/Q,
                                                                             l@Points:append(l@Points,PointWithHour(i,x,y)))),
                                                                   if len(l@Points) > 0 then block([],lines:append(lines,l))))),
                                        center@Y:-(a/tφ),u:a/math@Abs(sφ),throw('return(null)))),
                        if %% # null then %% else [lines,center,u])$
 
 
Vertical(φ,D,a):=block([lines,center,u],
         returning(block([cφ,sφ,tφ,cD,sD],[sφ,cφ]:Sincos[go_type_of(φ)](φ)(),tφ:sφ/cφ,[sD,cD]:Sincos[go_type_of(D)](D)(),
                         for i from 0 unless i >= 24 do
                             continuing(block([l,H,aH,cH,sH],l:block([x:new(Line)],x@Hour:i,x),H:(float64(i-12)*math@Pi)/12,aH:math@Abs(H),
                                              [sH,cH]:math@Sincos(H),
                                              for _ from 0 thru length(m)-1 do
                                                  continuing(block([d:m[_+1]],
                                                                   block([tδ,H0,Q,x,y],tδ:math@Tan((d*math@Pi)/180),H0:math@Acos(-(tδ*tφ)),
                                                                         if aH > H0 then block([],throw(continue)),
                                                                         Q:-(cD*cφ*tδ)+cD*cH*sφ+sD*sH,
                                                                         if Q < 0 then block([],throw(continue)),
                                                                         x:(a*(cφ*sD*tδ-cH*sD*sφ+cD*sH))/Q,y:-((a*(sφ*tδ+cH*cφ))/Q),
                                                                         l@Points:append(l@Points,Point(x,y))))),
                                              if len(l@Points) > 0 then block([],lines:append(lines,l)))),center@X:-((a*sD)/cD),
                         center@Y:(a*tφ)/cD,u:a/math@Abs(cD*cφ),throw('return(null)))),if %% # null then %% else [lines,center,u])$
 
