push("/home/dodier/github/github-forks/maxima-packages/**/*.mac",file_search_maxima);
push("/home/dodier/github/github-forks/maxima-packages/**/*.lisp",file_search_lisp);
load(json_tools);

expr_from_blob(b):=if not atom(b) and op(b) = 'blob then funmake(parse_string(b // "NodeType"),other_fields(b)) else b;
other_fields(b):=block([L:[]],for e in args(b) do if lhs(e) # "NodeType" then push(e,L),reverse(L));

matchdeclare (ss, stringp, [ll, mm], listp, ff, symbolp, [aa, bb, cc], all);
defrule (symbol_from_Ident, Ident("Name" = ss), parse_string(ss));
defrule (string_from_BasicLit, BasicLit("Kind" = "STRING", "Value" = ss), parse_string(ss));
defrule (integer_from_BasicLit, BasicLit("Kind" = "INT", "Value" = ss), parse_string(ss));
defrule (float_from_BasicLit, BasicLit("Kind" = "FLOAT", "Value" = ss), parse_string (ss));
defrule (character_from_BasicLit, BasicLit("Kind" = "CHAR", "Value" = ss), charat (ss, 2));
defrule (list_from_null_List, "List" = null, []);
defrule (list_from_List, "List" = ll, ll);
defrule (list_from_FieldList, FieldList (ll), ll);

/* would prefer to have funmake here instead of apply, but funmake barfs on aa being a general expression; that's a bug in funmake !! */
defrule (funcall_no_args_from_CallExpr, CallExpr("Args" = null, "Fun" = aa), apply (aa, []));
defrule (funcall_from_CallExpr, CallExpr("Args" = ll, "Fun" = aa), apply (aa, ll));
defrule (equality_from_BinaryExpr_with_equalsequals, BinaryExpr ("Op" = "==", "X" = aa, "Y" = bb), funmake ('equal, [aa, bb]));
defrule (expr_from_BinaryExpr, BinaryExpr ("Op" = ss, "X" = aa, "Y" = bb), funmake (ss, [aa, bb]));
defrule (expr_from_UnaryExpr, UnaryExpr ("Op" = ss, "X" = aa), funmake (ss, [aa]));

/* return(...) in Go is a nonlocal return, so implement ReturnStmt as throw(...) in Maxima.
 * The corresponding catch(...) appears in the implementation of FuncDecl.
 * 
 * Also, Go functions have multiple return values, with the first being the primary return value,
 * as in Common Lisp. Returning a list in Maxima isn't quite the same.
 * For now, return a single value as a non-list, otherwise return a list. !!
 * Not sure how to handle multiple return values in general. !!
 */

defrule (throw_from_ReturnStmt,
         ReturnStmt ("Results" = ll),
         if length (ll) = 1 then buildq ([x: first (ll)], throw (x)) else buildq ([ll], throw (ll)));

defrule (throw_from_ReturnStmt_null,
         ReturnStmt ("Results" = null),
         buildq ([], throw (null)));

/* assignment should take into account the stuff above about multiple return values ... !! */
defrule (assignment_from_AssignStmt, AssignStmt ("Lhs" = ll, "Rhs" = mm, "Tok" = "="),
         if length (ll) = 1 and length (mm) = 1
             then buildq ([vv: ll[1], ee: mm[1]], vv : ee)
             else if length (mm) = 1
                      /* assume [a, b]: [foo] must mean [a, b]: foo -- not sure if that's always true !! */
                      then buildq ([ll, ee: mm[1]], ll : ee)
                      else buildq ([ll, mm], ll : mm));

defrule (assignment_with_addition_from_AssignStmt, AssignStmt ("Lhs" = ll, "Rhs" = mm, "Tok" = "+="),
         if length (ll) = 1 and length (mm) = 1
             then buildq ([vv: ll[1], ee: mm[1]], vv : vv + ee)
             else buildq ([ll, mm], ll : ll + mm));

defrule (assignment_with_subtraction_from_AssignStmt, AssignStmt ("Lhs" = ll, "Rhs" = mm, "Tok" = "-="),
         if length (ll) = 1 and length (mm) = 1
             then buildq ([vv: ll[1], ee: mm[1]], vv : vv - ee)
             else buildq ([ll, mm], ll : ll - mm));

defrule (local_var_assignment_from_AssignStmt, AssignStmt ("Lhs" = ll, "Rhs" = mm, "Tok" = ":="),
         buildq ([ll, mm], var (ll) : mm));

defrule (block_from_BlockStmt, BlockStmt (ll), buildq ([ll], block (splice (ll))));

defrule (expr_from_ParenExpr, ParenExpr ("X" = aa), aa);

/* not sure how to handle method calls here -- handle at run time?? substitute f(x) for x@f when f is known to be a method?? */
defrule (at_sign_from_SelectorExpr, SelectorExpr ("Sel" = aa, "X" = bb), buildq ([aa, bb], "@"(bb, aa)));

defrule (if_then_from_IfStmt,
         IfStmt ("Body" = aa, "Cond" = bb, "Else" = null, "Init" = null),
         buildq ([aa, bb], if bb then aa));

defrule (if_then_else_from_IfStmt,
         IfStmt ("Body" = aa, "Cond" = bb, "Else" = cc, "Init" = null),
         buildq ([aa, bb, cc], if bb then aa else cc));

/* match FuncDecl with "Recv" = null; that's an ordinary function.
 * Additionally match "TypeParams" = null; not sure yet what to do otherwise.
 */

defrule (function_from_FuncDecl_function,
         FuncDecl ("Body" = aa, "Name" = ff, "Recv" = null, "Type" = FuncType ("Params" = ll, "Results" = cc, "TypeParams" = null)),
         construct_function_definition (ff, aa, ll, cc));

construct_function_definition (function_name, body, arguments, results) :=
    block ([args_symbols: extract_arguments_symbols (arguments),
            results_names: extract_results_names (results)],
           if results_names = []
               then buildq ([function_name, args_symbols, body],
                            function_name (splice (args_symbols)) := catch (body))
               else buildq ([function_name, args_symbols, body, results_names],
                            function_name (splice (args_symbols)) := block (results_names, catch (body), results_names)));

extract_arguments_symbols (arguments) :=
    (map (lambda ([e], assoc ("Names", e)), arguments),
     apply (append, %%));

extract_results_names (results) :=
    block ([names: map (lambda ([e], assoc ("Names", e)), results)],
           apply (append, subst (null = [], names)));

/* match FuncDecl with "Recv" # null; that's a method.
 * Additionally match "TypeParams" = null; not sure yet what to do otherwise.
 */

defrule (function_from_FuncDecl_method,
         FuncDecl ("Body" = aa, "Name" = ff, "Recv" = bb, "Type" = FuncType ("Params" = ll, "Results" = cc, "TypeParams" = null)),
         construct_method_definition (ff, aa, bb, ll, cc));

construct_method_definition (method_name, body, receiver, arguments, results) :=
    block ([args_symbols: extract_arguments_symbols (arguments),
            recv_symbol: extract_receiver_symbol (receiver),
            recv_type: extract_receiver_type (receiver),
            results_names: extract_results_names (results)],
           push (method_name [recv_type], methods_list),
           if results_names = []
               then buildq ([method_name, recv_symbol, recv_type, args_symbols, body],
                            method_name [recv_type] (recv_symbol) :=
                                buildq ([recv_value: recv_symbol],
                                        lambda (args_symbols, block ([recv_symbol: recv_value], catch (body)))))
               else buildq ([method_name, recv_symbol, recv_type, args_symbols, body, results_names],
                            method_name [recv_type] (recv_symbol) :=
                                buildq ([recv_value: recv_symbol],
                                        lambda (args_symbols, block (results_names, block ([recv_symbol: recv_value], catch (body)), results_names)))));

extract_receiver_symbol (receiver) :=
    /* receiver is apparently always a list of exactly one element,
     * because, from what I can tell, Go does not allow two or more receivers.
     * Given that, I don't know why the receiver is supplied as a list.
     * Code here assumes a list of one element, containing a list of one element.
     */
    first (assoc ("Names", first (receiver)));

extract_receiver_type (receiver) :=
    /* "Type" is a single element, while "Names" is a list ... not sure what's going on there.
     */
    assoc ("Type", first (receiver));

matchdeclare (mm, lambda ([e], symbolp (e) and member (e, methods_list_names_only)));

/* we seem to be running into noun/verb (%@/$@) confusion here ... not sure what's right */

/*
foo: (aa@mm)();
defrule (rewrite_method_calls_no_args, ''foo, mm[go_type_of (aa)](aa));
foo: (aa@mm)(bb);
defrule (rewrite_method_calls_one_arg, ''foo, mm[go_type_of (aa)](aa)(bb));
 */

defrule (rewrite_method_calls_no_args, (aa@mm)(), mm[go_type_of (aa)](aa));
defrule (rewrite_method_calls_one_arg, (aa@mm)(bb), mm[go_type_of (aa)](aa)(bb));

'(catch (block (throw (aa))));
defrule (collapse_catch_block_throw1, ''%, aa);
'(catch (block ([], throw (aa))));
defrule (collapse_catch_block_throw2, ''%, aa);

apply_all_rules (b) :=
    block ([e1, e2, e3, e4, e4a, e4b, e5, e6, e7, e8, e9],
           e1: scanmap (expr_from_blob, b),
           e2: apply1 (e1, symbol_from_Ident, string_from_BasicLit, integer_from_BasicLit, float_from_BasicLit, character_from_BasicLit, list_from_null_List, list_from_List, list_from_FieldList, expr_from_ParenExpr),
           e3: apply1 (e2, funcall_no_args_from_CallExpr, funcall_from_CallExpr, equality_from_BinaryExpr_with_equalsequals, expr_from_BinaryExpr, expr_from_UnaryExpr),
           e4: apply1 (e3, throw_from_ReturnStmt_null, throw_from_ReturnStmt, block_from_BlockStmt, local_var_assignment_from_AssignStmt),
           e4a: lift_local_vars_into_block (e4),
           e4b: apply1 (e4a, assignment_from_AssignStmt, assignment_with_addition_from_AssignStmt, assignment_with_subtraction_from_AssignStmt, if_then_from_IfStmt),
           e5: apply1 (e4b, if_then_else_from_IfStmt, at_sign_from_SelectorExpr),
           e6: apply1 (e5, function_from_FuncDecl_function, function_from_FuncDecl_method),
           methods_list_names_only: setify (map (op, methods_list)),
           e7: apply1 (e6, rewrite_method_calls_no_args, rewrite_method_calls_one_arg),
           e8: elide_trailing_throw_null (e7),
           e9: apply1 (e8, collapse_catch_block_throw1, collapse_catch_block_throw2),
           [e1, e2, e3, e4, e4a, e4b, e5, e6, e7, e8, e9]);

lift_local_vars_into_block (e) :=
    scanmap (lift_local_vars_into_block1, e);

lift_local_vars_into_block1 (e) :=
    if not atom(e) and op(e) = block
        then block ([vars: [], exprs: []],
                    for e1 in e
                        do (if match_local_var_assignment (e1) # false
                                then (push (vv, vars),
                                      if length (vv) = 1 and length (xx) = 1
                                          then buildq ([vv1: vv[1], xx1: xx[1]], vv1 : xx1)
                                          else if length (xx) = 1
                                                   /* assume [a, b]: [foo] must mean [a, b]: foo -- not sure if that's always true !! */
                                                   then buildq ([vv, xx1: xx[1]], vv : xx1)
                                                   else buildq ([vv, xx], vv: xx),
                                      push (%%, exprs))
                                else push (e1, exprs)),
                    buildq ([vars: reverse (apply (append, vars)), exprs: reverse (exprs)],
                            block (vars, splice (exprs))))
        else e;

matchdeclare (vv, lambda ([e], listp (e) and every (symbolp, e)), xx, all);
defmatch (match_local_var_assignment, var (vv) : xx);

elide_trailing_throw_null (e) :=
    scanmap (elide_trailing_throw_null1, e);

elide_trailing_throw_null1 (e) :=
    if not atom (e) and op (e) = block
        then if last (e) = '(throw (null))
                 then rest (e, -1)
                 else e
        else e;

/* ideally maintain one list per module or package, not sure which */
methods_list: [];

blob1:read_json("FromSexa.json");
results1: apply_all_rules (blob1);
grind (last (results1));
''(last (results1));

blob2: read_json ("FromSexaSec.json");
results2: apply_all_rules (blob2);
grind (last (results2));
''(last (results2));

FromSexa ("+", hh, mm, ss);
FromSexa ("-", hh, mm, ss);

kill (FromSexa, FromSexaSec);

unit_blobs: read_json ("unit1.json");
unit_decls: unit_blobs // "Decls" $
unit_results: map (apply_all_rules, unit_decls) $

print ("output results from apply_all_rules on unit_decls to unit_go.mac.") $

with_stdout ("unit_go.mac",
    for results in unit_results
        do (print (""),
            grind (last (results)),
            print ("")));

print ("found", length (methods_list), "methods in unit1.json:", reverse (methods_list));

solar_blobs: read_json ("solar1.json");
solar_decls: solar_blobs // "Decls" $
solar_results: map (apply_all_rules, solar_decls);

print ("output results from apply_all_rules on solar_decls to solar_go.mac.") $

with_stdout ("solar_go.mac",
    for results in solar_results
        do (print (""),
            grind (last (results)),
            print ("")));

